{
  "hash": "b6c45b828c6bb56baa8eeea7b2778bc3",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Análisis Exploratorio, Transformación Condicional y Funciones con `map()`\"\nsubtitle: \"Análisis de Datos 1\"\nauthor: \"Betsy Cohen\"\nlogo: \"images/logo-uflo.png\"\ndate: \"08/05/2025\"\nformat:\n  revealjs:\n    width: 1600\n    height: 900\n    theme: slides.scss\n    highlight-style: a11y\n    transition: fade\n    slide-number: true\nexecute:\n  echo: true\ndf-print: kable\n---\n\n\n\n\n# Exploración, Transformación Condicional y la Magia de map() 🚀\n\nEn la clase de hoy, vamos a explorar tres aspectos fundamentales del análisis de datos:\n\n-   Repaso de Análisis Exploratorio y Descriptivo: Resúmenes clave para datos numéricos y categóricos.\n-   Lógica Condicional con if_else() y case_when(): Transformación de datos basada en condiciones.\n-   Introducción a purrr::map(): La función map() para aplicar operaciones a múltiples elementos de forma eficiente y elegante.\n\n# Análisis Exploratorio y Descriptivo 🔍\n\nVamos a repasar brevemente las herramientas esenciales para entender nuestros datos, tanto numéricos como categóricos.\n\n## Datos Numéricos: Resúmenes Estadísticos 🔢 {.smaller}\n\nPara variables numéricas, los resúmenes estadísticos nos ofrecen una visión rápida de su distribución y características.\n\n**Herramientas:**\n\n-   `summarize()`: Para calcular estadísticos como media, mediana, desviación estándar, etc.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    resumen_edad <- encc_2022 %>%\n      summarize(\n        media_edad = mean(edad, na.rm = TRUE),\n        mediana_edad = median(edad, na.rm = TRUE),\n        desvio_std_edad = sd(edad, na.rm = TRUE),\n        min_edad = min(edad, na.rm = TRUE),\n        max_edad = max(edad, na.rm = TRUE),\n        rango_edad = max_edad - min_edad,\n        iqr_edad = IQR(edad, na.rm = TRUE),\n        cantidad_encuestados = n()\n      )\n    ```\n    :::\n\n\n## Datos Numéricos: Resúmenes Estadísticos 🔢\n\n::: columns\n::: {.column width=\"50%\"}\nEsta tabla nos presenta un resumen conciso de la distribución de la edad en la muestra, mostrando medidas de tendencia central, dispersión y rango.\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nresumen_edad\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| media_edad| mediana_edad| desvio_std_edad| min_edad| max_edad| rango_edad| iqr_edad| cantidad_encuestados|\n|----------:|------------:|---------------:|--------:|--------:|----------:|--------:|--------------------:|\n|   44.27337|           43|        18.68123|       13|       91|         78|       30|                 3380|\n\n</div>\n:::\n:::\n\n:::\n:::\n\n## Datos Categóricos: Tablas de Frecuencia 📊 {.smaller}\n\nPara variables categóricas, las tablas de frecuencia nos muestran la distribución de las categorías y su importancia relativa.\n\n::: columns\n::: {.column width=\"50%\"}\n**Herramientas:**\n\n-   `count()`: Para contar las ocurrencias de cada categoría.\n\n-   `mutate()`: Para calcular proporciones y porcentajes a partir de las frecuencias.\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nfrecuencia_regiones_prop <- encc_2022 %>%\n  count(region, sort = TRUE) %>%\n  mutate(\n    proporcion = n / sum(n),\n    porcentaje = proporcion * 100\n  )\n\nfrecuencia_regiones_prop\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|region    |   n| proporcion| porcentaje|\n|:---------|---:|----------:|----------:|\n|GBA       | 620|  0.1834320|   18.34320|\n|CENTRO    | 608|  0.1798817|   17.98817|\n|NEA       | 448|  0.1325444|   13.25444|\n|NOA       | 446|  0.1319527|   13.19527|\n|PATAGONIA | 439|  0.1298817|   12.98817|\n|CUYO      | 431|  0.1275148|   12.75148|\n|CABA      | 388|  0.1147929|   11.47929|\n\n</div>\n:::\n:::\n\n:::\n:::\n\nEsta tabla muestra las regiones ordenadas por frecuencia, junto con la cantidad de encuestados en cada región, su proporción y porcentaje respecto al total de la muestra.\n\n# Lógica Condicional: `if_else()` y `case_when()` 🤔\n\n## `if_else()`: Condiciones Binarias (SI/NO) 💡 {.smaller}\n\n`if_else()` es ideal para crear variables basadas en una condición que tiene dos resultados posibles.\n\n**Ejemplo: Variable `es_mayor_de_50`**\n\nCreemos una variable que indique si la edad del encuestado es mayor de 50 años (SI/NO).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nencc_mayor_50 <- encc_2022 %>%\n  mutate(\n    es_mayor_de_50 = if_else(edad > 50, \"SI\", \"NO\")\n  )\n\nencc_mayor_50 %>% count(es_mayor_de_50)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|es_mayor_de_50 |    n|\n|:--------------|----:|\n|NO             | 2139|\n|SI             | 1241|\n\n</div>\n:::\n:::\n\n\n`if_else()` asigna \"SI\" a `es_mayor_de_50` si `edad > 50` es verdadero, y \"NO\" en caso contrario.\n\n## `case_when()`: Condiciones Múltiples y Categorías 🎭 {.smaller}\n\n`case_when()` es perfecto para lógica condicional más compleja con múltiples categorías.\n\nRecategorizamos `nse_3` en \"Alto/Medio\", \"Bajo\" y \"Sin Dato\".\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nencc_nse_reducido <- encc_2022 %>%\n  mutate(\n    nse_reducido = case_when(\n      nse_3 %in% c(\"ABC1\", \"C2C3\") ~ \"Alto/Medio\",\n      nse_3 == \"D1D2E\"           ~ \"Bajo\",\n      TRUE                         ~ \"Sin Dato\"\n    )\n  )\n```\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nencc_nse_reducido %>% count(nse_reducido)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|nse_reducido |    n|\n|:------------|----:|\n|Alto/Medio   |  327|\n|Sin Dato     | 3053|\n\n</div>\n:::\n:::\n\n:::\n:::\n\n`case_when()` asigna categorías a `nse_reducido` basadas en diferentes condiciones aplicadas a `nse_3`, incluyendo un valor por defecto \"Sin Dato\".\n\n::: callout-note\ncase_when () es una de las estructuras de transformación que seguramente más vas usar. Si ya contas con algo de experiencia en análisis de datos y trabajaste con SPSS case_when() es uno de los procesos que hacemos más habitualmente en lo que llamamos **rectegorización** de variables\n:::\n\n# Introducción a `purrr::map()`: La Magia de la Iteración Funcional ✨\n\nAhora vamos a introducir una herramienta muy poderosa para **automatizar tareas repetitivas**: la función `map()` del paquete `purrr`.\n\n## ¿Qué es `map()`?\n\n-   `map()` es una función que permite aplicar la **misma función** a **cada elemento de una lista o vector**.\n\n-   Simplifica y hace más eficiente el código cuando necesitamos realizar la misma operación en múltiples columnas o elementos.\n\n-   Es un concepto clave de la **programación funcional**.\n\n## Sintaxis básica de `map()`:\n\nmap() nos va a pedir dos elementos básicos para operar como parte de su sintaxis\n\n-   `x`: El **vector o lista** sobre el cual queremos iterar.\n\n<!-- -->\n\n-   `.f`: La **función** que queremos aplicar a cada elemento de `.x`.\n\nComo resultado devuelve una **lista** donde cada elemento es el resultado de aplicar la función `.f` al elemento correspondiente de `.x`.\n\nVeamos un ejemplo\n\n## Calcular Tablas de Frecuencia para Múltiples Variables Categóricas con `map()` y `count()` 📊 {.smaller}\n\nSupongamos que queremos obtener las tablas de frecuencia para varias variables categóricas de la ENCC_2022: `region`, `genero`, `nivel_educativo`. En lugar de escribir `count()` para cada variable por separado, podemos usar `map()` para automatizar este proceso.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvariables_categoricas <- c(\"region\", \"genero\", \"niv_socioe\") # Vector de nombres de variables categóricas\n\nfrecuencias_variables <- map(\n  .x = variables_categoricas, # Vector de nombres de variables categóricas sobre el que iterar\n  .f = function(variable) { # Función anónima que toma el nombre de una variable como argumento\n    encc_2022 %>%\n      count(!!sym(variable), sort = TRUE) # Calcula la tabla de frecuencia para la variable en el dataset encc_2022\n  }\n)\n```\n:::\n\n\n## Calcular Tablas de Frecuencia para Múltiples Variables Categóricas con `map()` y `count()` 📊 {.smaller}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfrecuencias_variables # Imprimir la lista de data frames de frecuencias\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n     region   n\n1       GBA 620\n2    CENTRO 608\n3       NEA 448\n4       NOA 446\n5 PATAGONIA 439\n6      CUYO 431\n7      CABA 388\n\n[[2]]\n      genero    n\n1      Mujer 2005\n2      Varón 1374\n3 No binario    1\n\n[[3]]\n  niv_socioe    n\n1         C3 1119\n2         D1  953\n3         C2  648\n4        D2E  333\n5       ABC1  327\n```\n\n\n:::\n:::\n\n\n## 😱Pero ... ¿¡Qué es esta locura!?\n\n-   `map()` iteró sobre el vector `variables_categoricas`. Para cada nombre de variable (ej., \"region\"), aplicó la función anónima.\n\n<!-- -->\n\n-   La función anónima usa `count(!!sym(variable), sort = TRUE)` para calcular la tabla de frecuencia de la variable actual, ordenando por frecuencia descendente.\n\n<!-- -->\n\n-   `!!sym(variable)`: Recordemos que esto permite usar el nombre de la variable dinámicamente dentro de `count()`.\n\n<!-- -->\n\n-   El resultado `frecuencias_variables` es una **lista**, donde cada elemento es un **data frame** que representa la tabla de frecuencia para una de las variables categóricas. Cada data frame muestra las categorías y sus frecuencias (`n`).\n\n## Calcular Tablas de Proporciones para Múltiples Variables Categóricas con `map()` y Funciones Anidadas 📈 {.smaller}\n\nAhora, vamos a calcular las tablas de proporciones (y porcentajes) para las mismas variables categóricas (`region`, `genero`, `nivel_educativo`). Vamos a anidar funciones dentro de `map()` para realizar los cálculos de proporción dentro de cada tabla de frecuencia.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nproporciones_variables <- map(\n  .x = variables_categoricas, # Vector de nombres de variables categóricas\n  .f = function(variable) { # Función anónima para calcular tabla de proporciones para una variable\n    encc_2022 %>%\n      count(!!sym(variable), sort = TRUE) %>% # Primero, calcular la tabla de frecuencia\n      mutate( # Luego, dentro de la misma función anónima, calcular proporciones y porcentajes\n        proporcion = n / sum(n),\n        porcentaje = proporcion * 100\n      )\n  }\n)\n```\n:::\n\n\n## Calcular Tablas de Proporciones para Múltiples Variables Categóricas con `map()` y Funciones Anidadas 📈\n\n\n::: {.cell}\n\n```{.r .cell-code}\nproporciones_variables # Imprimir la lista de data frames de proporciones\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n     region   n proporcion porcentaje\n1       GBA 620  0.1834320   18.34320\n2    CENTRO 608  0.1798817   17.98817\n3       NEA 448  0.1325444   13.25444\n4       NOA 446  0.1319527   13.19527\n5 PATAGONIA 439  0.1298817   12.98817\n6      CUYO 431  0.1275148   12.75148\n7      CABA 388  0.1147929   11.47929\n\n[[2]]\n      genero    n  proporcion porcentaje\n1      Mujer 2005 0.593195266 59.3195266\n2      Varón 1374 0.406508876 40.6508876\n3 No binario    1 0.000295858  0.0295858\n\n[[3]]\n  niv_socioe    n proporcion porcentaje\n1         C3 1119 0.33106509  33.106509\n2         D1  953 0.28195266  28.195266\n3         C2  648 0.19171598  19.171598\n4        D2E  333 0.09852071   9.852071\n5       ABC1  327 0.09674556   9.674556\n```\n\n\n:::\n:::\n\n\n## ¡Es mágico!\n\n-   De nuevo, `map()` iteró sobre `variables_categoricas`.\n\n<!-- -->\n\n-   La función anónima ahora realiza dos operaciones anidadas:\n\n    1.  `count(!!sym(variable), sort = TRUE)`: Calcula la tabla de frecuencia (como el ej. anterior).\n\n    2.  `mutate(proporcion = n / sum(n), porcentaje = proporcion * 100)`: *Dentro del mismo pipe*, calcula las columnas `proporcion` y `porcentaje` a partir de la frecuencia `n` de la tabla de frecuencia.\n\n-   El resultado `proporciones_variables` es una **lista**, donde cada elemento es un **data frame** que contiene la tabla de frecuencia y las proporciones/porcentajes para cada variable categórica.\n\n## La yapa: Combinar las Tablas en un Solo Data Frame con `list_rbind()` y un ID de Variable 🧲 {.smaller}\n\nFinalmente, combinemos las listas de tablas de proporciones (`proporciones_variables`) en un único data frame \"largo\", y agreguemos una columna `variable` para identificar a qué variable categórica corresponde cada tabla.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nproporciones_variables_df <- proporciones_variables %>%\n  list_rbind(names_to = \"variable\") # Combinar la lista en un data frame y usar 'names_to' para crear columna 'variable'\n\nstr(proporciones_variables_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t15 obs. of  7 variables:\n $ variable  : int  1 1 1 1 1 1 1 2 2 2 ...\n $ region    : chr  \"GBA\" \"CENTRO\" \"NEA\" \"NOA\" ...\n $ n         : int  620 608 448 446 439 431 388 2005 1374 1 ...\n $ proporcion: num  0.183 0.18 0.133 0.132 0.13 ...\n $ porcentaje: num  18.3 18 13.3 13.2 13 ...\n $ genero    : chr  NA NA NA NA ...\n $ niv_socioe: chr  NA NA NA NA ...\n```\n\n\n:::\n:::\n\n\nAhora tenemos un data frame \"tidy\" donde cada fila representa una categoría de una variable categórica, con columnas para la variable, la categoría, la frecuencia, la proporción y el porcentaje. Este formato facilita la comparación de distribuciones entre diferentes variables categóricas, y puede ser usado para crear visualizaciones tabulares o gráficas comparativas (aunque en esta clase no estemos usando gráficos).\n\n## `map()`: Un Universo de Posibilidades 🌌 {.smaller}\n\nLa función `map()` es extremadamente versátil y puede usarse con una gran variedad de funciones y propósitos. En clases futuras, exploraremos más usos de `map()` y otras funciones del paquete `purrr` para la programación funcional y la manipulación de datos avanzada.\n\n**En resumen, `map()` nos permite:**\n\n-   **Automatizar tareas repetitivas** de forma eficiente y concisa.\n\n-   **Aplicar la misma lógica a múltiples columnas o elementos** de una lista o vector.\n\n-   **Escribir código más limpio, legible y mantenible**.\n\n-   **Adoptar un estilo de programación funcional** que es poderoso y común en el ecosistema de R y `tidyverse`.\n\n::: callout-note\nSi te interesa aprender más sobre map() y sus aplicaciones podes consultar la documentación (que por suerte viene con muchos ejemplos) en [https://purrr.tidyverse.org/reference/map.html](https://purrr.tidyverse.org/reference/map.html)\n:::\n\n# Resumen de la Clase de Hoy 🚀\n\nEn la clase de hoy, cubrimos tres temas importantes:\n\n-   **Análisis Exploratorio Descriptivo**: Repasamos resúmenes estadísticos para datos numéricos y tablas de frecuencia para datos categóricos.\n\n-   **Lógica Condicional con `if_else()` y `case_when()`**: Reforzamos el uso de estas funciones para transformaciones basadas en condiciones.\n\n-   **Introducción a `purrr::map()`**: Aprendimos los fundamentos de la función `map()` para la iteración funcional, y cómo usar `map_dbl()` y `map()` para aplicar funciones a múltiples variables, y combinar los resultados con `list_rbind()`.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}