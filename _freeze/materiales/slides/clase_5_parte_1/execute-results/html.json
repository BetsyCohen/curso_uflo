{
  "hash": "b6c45b828c6bb56baa8eeea7b2778bc3",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"An谩lisis Exploratorio, Transformaci贸n Condicional y Funciones con `map()`\"\nsubtitle: \"An谩lisis de Datos 1\"\nauthor: \"Betsy Cohen\"\nlogo: \"images/logo-uflo.png\"\ndate: \"08/05/2025\"\nformat:\n  revealjs:\n    width: 1600\n    height: 900\n    theme: slides.scss\n    highlight-style: a11y\n    transition: fade\n    slide-number: true\nexecute:\n  echo: true\ndf-print: kable\n---\n\n\n\n\n# Exploraci贸n, Transformaci贸n Condicional y la Magia de map() \n\nEn la clase de hoy, vamos a explorar tres aspectos fundamentales del an谩lisis de datos:\n\n-   Repaso de An谩lisis Exploratorio y Descriptivo: Res煤menes clave para datos num茅ricos y categ贸ricos.\n-   L贸gica Condicional con if_else() y case_when(): Transformaci贸n de datos basada en condiciones.\n-   Introducci贸n a purrr::map(): La funci贸n map() para aplicar operaciones a m煤ltiples elementos de forma eficiente y elegante.\n\n# An谩lisis Exploratorio y Descriptivo \n\nVamos a repasar brevemente las herramientas esenciales para entender nuestros datos, tanto num茅ricos como categ贸ricos.\n\n## Datos Num茅ricos: Res煤menes Estad铆sticos  {.smaller}\n\nPara variables num茅ricas, los res煤menes estad铆sticos nos ofrecen una visi贸n r谩pida de su distribuci贸n y caracter铆sticas.\n\n**Herramientas:**\n\n-   `summarize()`: Para calcular estad铆sticos como media, mediana, desviaci贸n est谩ndar, etc.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    resumen_edad <- encc_2022 %>%\n      summarize(\n        media_edad = mean(edad, na.rm = TRUE),\n        mediana_edad = median(edad, na.rm = TRUE),\n        desvio_std_edad = sd(edad, na.rm = TRUE),\n        min_edad = min(edad, na.rm = TRUE),\n        max_edad = max(edad, na.rm = TRUE),\n        rango_edad = max_edad - min_edad,\n        iqr_edad = IQR(edad, na.rm = TRUE),\n        cantidad_encuestados = n()\n      )\n    ```\n    :::\n\n\n## Datos Num茅ricos: Res煤menes Estad铆sticos \n\n::: columns\n::: {.column width=\"50%\"}\nEsta tabla nos presenta un resumen conciso de la distribuci贸n de la edad en la muestra, mostrando medidas de tendencia central, dispersi贸n y rango.\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nresumen_edad\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| media_edad| mediana_edad| desvio_std_edad| min_edad| max_edad| rango_edad| iqr_edad| cantidad_encuestados|\n|----------:|------------:|---------------:|--------:|--------:|----------:|--------:|--------------------:|\n|   44.27337|           43|        18.68123|       13|       91|         78|       30|                 3380|\n\n</div>\n:::\n:::\n\n:::\n:::\n\n## Datos Categ贸ricos: Tablas de Frecuencia  {.smaller}\n\nPara variables categ贸ricas, las tablas de frecuencia nos muestran la distribuci贸n de las categor铆as y su importancia relativa.\n\n::: columns\n::: {.column width=\"50%\"}\n**Herramientas:**\n\n-   `count()`: Para contar las ocurrencias de cada categor铆a.\n\n-   `mutate()`: Para calcular proporciones y porcentajes a partir de las frecuencias.\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nfrecuencia_regiones_prop <- encc_2022 %>%\n  count(region, sort = TRUE) %>%\n  mutate(\n    proporcion = n / sum(n),\n    porcentaje = proporcion * 100\n  )\n\nfrecuencia_regiones_prop\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|region    |   n| proporcion| porcentaje|\n|:---------|---:|----------:|----------:|\n|GBA       | 620|  0.1834320|   18.34320|\n|CENTRO    | 608|  0.1798817|   17.98817|\n|NEA       | 448|  0.1325444|   13.25444|\n|NOA       | 446|  0.1319527|   13.19527|\n|PATAGONIA | 439|  0.1298817|   12.98817|\n|CUYO      | 431|  0.1275148|   12.75148|\n|CABA      | 388|  0.1147929|   11.47929|\n\n</div>\n:::\n:::\n\n:::\n:::\n\nEsta tabla muestra las regiones ordenadas por frecuencia, junto con la cantidad de encuestados en cada regi贸n, su proporci贸n y porcentaje respecto al total de la muestra.\n\n# L贸gica Condicional: `if_else()` y `case_when()` \n\n## `if_else()`: Condiciones Binarias (SI/NO)  {.smaller}\n\n`if_else()` es ideal para crear variables basadas en una condici贸n que tiene dos resultados posibles.\n\n**Ejemplo: Variable `es_mayor_de_50`**\n\nCreemos una variable que indique si la edad del encuestado es mayor de 50 a帽os (SI/NO).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nencc_mayor_50 <- encc_2022 %>%\n  mutate(\n    es_mayor_de_50 = if_else(edad > 50, \"SI\", \"NO\")\n  )\n\nencc_mayor_50 %>% count(es_mayor_de_50)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|es_mayor_de_50 |    n|\n|:--------------|----:|\n|NO             | 2139|\n|SI             | 1241|\n\n</div>\n:::\n:::\n\n\n`if_else()` asigna \"SI\" a `es_mayor_de_50` si `edad > 50` es verdadero, y \"NO\" en caso contrario.\n\n## `case_when()`: Condiciones M煤ltiples y Categor铆as  {.smaller}\n\n`case_when()` es perfecto para l贸gica condicional m谩s compleja con m煤ltiples categor铆as.\n\nRecategorizamos `nse_3` en \"Alto/Medio\", \"Bajo\" y \"Sin Dato\".\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nencc_nse_reducido <- encc_2022 %>%\n  mutate(\n    nse_reducido = case_when(\n      nse_3 %in% c(\"ABC1\", \"C2C3\") ~ \"Alto/Medio\",\n      nse_3 == \"D1D2E\"           ~ \"Bajo\",\n      TRUE                         ~ \"Sin Dato\"\n    )\n  )\n```\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nencc_nse_reducido %>% count(nse_reducido)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|nse_reducido |    n|\n|:------------|----:|\n|Alto/Medio   |  327|\n|Sin Dato     | 3053|\n\n</div>\n:::\n:::\n\n:::\n:::\n\n`case_when()` asigna categor铆as a `nse_reducido` basadas en diferentes condiciones aplicadas a `nse_3`, incluyendo un valor por defecto \"Sin Dato\".\n\n::: callout-note\ncase_when () es una de las estructuras de transformaci贸n que seguramente m谩s vas usar. Si ya contas con algo de experiencia en an谩lisis de datos y trabajaste con SPSS case_when() es uno de los procesos que hacemos m谩s habitualmente en lo que llamamos **rectegorizaci贸n** de variables\n:::\n\n# Introducci贸n a `purrr::map()`: La Magia de la Iteraci贸n Funcional \n\nAhora vamos a introducir una herramienta muy poderosa para **automatizar tareas repetitivas**: la funci贸n `map()` del paquete `purrr`.\n\n## 驴Qu茅 es `map()`?\n\n-   `map()` es una funci贸n que permite aplicar la **misma funci贸n** a **cada elemento de una lista o vector**.\n\n-   Simplifica y hace m谩s eficiente el c贸digo cuando necesitamos realizar la misma operaci贸n en m煤ltiples columnas o elementos.\n\n-   Es un concepto clave de la **programaci贸n funcional**.\n\n## Sintaxis b谩sica de `map()`:\n\nmap() nos va a pedir dos elementos b谩sicos para operar como parte de su sintaxis\n\n-   `x`: El **vector o lista** sobre el cual queremos iterar.\n\n<!-- -->\n\n-   `.f`: La **funci贸n** que queremos aplicar a cada elemento de `.x`.\n\nComo resultado devuelve una **lista** donde cada elemento es el resultado de aplicar la funci贸n `.f` al elemento correspondiente de `.x`.\n\nVeamos un ejemplo\n\n## Calcular Tablas de Frecuencia para M煤ltiples Variables Categ贸ricas con `map()` y `count()`  {.smaller}\n\nSupongamos que queremos obtener las tablas de frecuencia para varias variables categ贸ricas de la ENCC_2022: `region`, `genero`, `nivel_educativo`. En lugar de escribir `count()` para cada variable por separado, podemos usar `map()` para automatizar este proceso.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvariables_categoricas <- c(\"region\", \"genero\", \"niv_socioe\") # Vector de nombres de variables categ贸ricas\n\nfrecuencias_variables <- map(\n  .x = variables_categoricas, # Vector de nombres de variables categ贸ricas sobre el que iterar\n  .f = function(variable) { # Funci贸n an贸nima que toma el nombre de una variable como argumento\n    encc_2022 %>%\n      count(!!sym(variable), sort = TRUE) # Calcula la tabla de frecuencia para la variable en el dataset encc_2022\n  }\n)\n```\n:::\n\n\n## Calcular Tablas de Frecuencia para M煤ltiples Variables Categ贸ricas con `map()` y `count()`  {.smaller}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfrecuencias_variables # Imprimir la lista de data frames de frecuencias\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n     region   n\n1       GBA 620\n2    CENTRO 608\n3       NEA 448\n4       NOA 446\n5 PATAGONIA 439\n6      CUYO 431\n7      CABA 388\n\n[[2]]\n      genero    n\n1      Mujer 2005\n2      Var贸n 1374\n3 No binario    1\n\n[[3]]\n  niv_socioe    n\n1         C3 1119\n2         D1  953\n3         C2  648\n4        D2E  333\n5       ABC1  327\n```\n\n\n:::\n:::\n\n\n## Pero ... 驴隆Qu茅 es esta locura!?\n\n-   `map()` iter贸 sobre el vector `variables_categoricas`. Para cada nombre de variable (ej., \"region\"), aplic贸 la funci贸n an贸nima.\n\n<!-- -->\n\n-   La funci贸n an贸nima usa `count(!!sym(variable), sort = TRUE)` para calcular la tabla de frecuencia de la variable actual, ordenando por frecuencia descendente.\n\n<!-- -->\n\n-   `!!sym(variable)`: Recordemos que esto permite usar el nombre de la variable din谩micamente dentro de `count()`.\n\n<!-- -->\n\n-   El resultado `frecuencias_variables` es una **lista**, donde cada elemento es un **data frame** que representa la tabla de frecuencia para una de las variables categ贸ricas. Cada data frame muestra las categor铆as y sus frecuencias (`n`).\n\n## Calcular Tablas de Proporciones para M煤ltiples Variables Categ贸ricas con `map()` y Funciones Anidadas  {.smaller}\n\nAhora, vamos a calcular las tablas de proporciones (y porcentajes) para las mismas variables categ贸ricas (`region`, `genero`, `nivel_educativo`). Vamos a anidar funciones dentro de `map()` para realizar los c谩lculos de proporci贸n dentro de cada tabla de frecuencia.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nproporciones_variables <- map(\n  .x = variables_categoricas, # Vector de nombres de variables categ贸ricas\n  .f = function(variable) { # Funci贸n an贸nima para calcular tabla de proporciones para una variable\n    encc_2022 %>%\n      count(!!sym(variable), sort = TRUE) %>% # Primero, calcular la tabla de frecuencia\n      mutate( # Luego, dentro de la misma funci贸n an贸nima, calcular proporciones y porcentajes\n        proporcion = n / sum(n),\n        porcentaje = proporcion * 100\n      )\n  }\n)\n```\n:::\n\n\n## Calcular Tablas de Proporciones para M煤ltiples Variables Categ贸ricas con `map()` y Funciones Anidadas \n\n\n::: {.cell}\n\n```{.r .cell-code}\nproporciones_variables # Imprimir la lista de data frames de proporciones\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n     region   n proporcion porcentaje\n1       GBA 620  0.1834320   18.34320\n2    CENTRO 608  0.1798817   17.98817\n3       NEA 448  0.1325444   13.25444\n4       NOA 446  0.1319527   13.19527\n5 PATAGONIA 439  0.1298817   12.98817\n6      CUYO 431  0.1275148   12.75148\n7      CABA 388  0.1147929   11.47929\n\n[[2]]\n      genero    n  proporcion porcentaje\n1      Mujer 2005 0.593195266 59.3195266\n2      Var贸n 1374 0.406508876 40.6508876\n3 No binario    1 0.000295858  0.0295858\n\n[[3]]\n  niv_socioe    n proporcion porcentaje\n1         C3 1119 0.33106509  33.106509\n2         D1  953 0.28195266  28.195266\n3         C2  648 0.19171598  19.171598\n4        D2E  333 0.09852071   9.852071\n5       ABC1  327 0.09674556   9.674556\n```\n\n\n:::\n:::\n\n\n## 隆Es m谩gico!\n\n-   De nuevo, `map()` iter贸 sobre `variables_categoricas`.\n\n<!-- -->\n\n-   La funci贸n an贸nima ahora realiza dos operaciones anidadas:\n\n    1.  `count(!!sym(variable), sort = TRUE)`: Calcula la tabla de frecuencia (como el ej. anterior).\n\n    2.  `mutate(proporcion = n / sum(n), porcentaje = proporcion * 100)`: *Dentro del mismo pipe*, calcula las columnas `proporcion` y `porcentaje` a partir de la frecuencia `n` de la tabla de frecuencia.\n\n-   El resultado `proporciones_variables` es una **lista**, donde cada elemento es un **data frame** que contiene la tabla de frecuencia y las proporciones/porcentajes para cada variable categ贸rica.\n\n## La yapa: Combinar las Tablas en un Solo Data Frame con `list_rbind()` y un ID de Variable Р {.smaller}\n\nFinalmente, combinemos las listas de tablas de proporciones (`proporciones_variables`) en un 煤nico data frame \"largo\", y agreguemos una columna `variable` para identificar a qu茅 variable categ贸rica corresponde cada tabla.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nproporciones_variables_df <- proporciones_variables %>%\n  list_rbind(names_to = \"variable\") # Combinar la lista en un data frame y usar 'names_to' para crear columna 'variable'\n\nstr(proporciones_variables_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t15 obs. of  7 variables:\n $ variable  : int  1 1 1 1 1 1 1 2 2 2 ...\n $ region    : chr  \"GBA\" \"CENTRO\" \"NEA\" \"NOA\" ...\n $ n         : int  620 608 448 446 439 431 388 2005 1374 1 ...\n $ proporcion: num  0.183 0.18 0.133 0.132 0.13 ...\n $ porcentaje: num  18.3 18 13.3 13.2 13 ...\n $ genero    : chr  NA NA NA NA ...\n $ niv_socioe: chr  NA NA NA NA ...\n```\n\n\n:::\n:::\n\n\nAhora tenemos un data frame \"tidy\" donde cada fila representa una categor铆a de una variable categ贸rica, con columnas para la variable, la categor铆a, la frecuencia, la proporci贸n y el porcentaje. Este formato facilita la comparaci贸n de distribuciones entre diferentes variables categ贸ricas, y puede ser usado para crear visualizaciones tabulares o gr谩ficas comparativas (aunque en esta clase no estemos usando gr谩ficos).\n\n## `map()`: Un Universo de Posibilidades  {.smaller}\n\nLa funci贸n `map()` es extremadamente vers谩til y puede usarse con una gran variedad de funciones y prop贸sitos. En clases futuras, exploraremos m谩s usos de `map()` y otras funciones del paquete `purrr` para la programaci贸n funcional y la manipulaci贸n de datos avanzada.\n\n**En resumen, `map()` nos permite:**\n\n-   **Automatizar tareas repetitivas** de forma eficiente y concisa.\n\n-   **Aplicar la misma l贸gica a m煤ltiples columnas o elementos** de una lista o vector.\n\n-   **Escribir c贸digo m谩s limpio, legible y mantenible**.\n\n-   **Adoptar un estilo de programaci贸n funcional** que es poderoso y com煤n en el ecosistema de R y `tidyverse`.\n\n::: callout-note\nSi te interesa aprender m谩s sobre map() y sus aplicaciones podes consultar la documentaci贸n (que por suerte viene con muchos ejemplos) en [https://purrr.tidyverse.org/reference/map.html](https://purrr.tidyverse.org/reference/map.html)\n:::\n\n# Resumen de la Clase de Hoy \n\nEn la clase de hoy, cubrimos tres temas importantes:\n\n-   **An谩lisis Exploratorio Descriptivo**: Repasamos res煤menes estad铆sticos para datos num茅ricos y tablas de frecuencia para datos categ贸ricos.\n\n-   **L贸gica Condicional con `if_else()` y `case_when()`**: Reforzamos el uso de estas funciones para transformaciones basadas en condiciones.\n\n-   **Introducci贸n a `purrr::map()`**: Aprendimos los fundamentos de la funci贸n `map()` para la iteraci贸n funcional, y c贸mo usar `map_dbl()` y `map()` para aplicar funciones a m煤ltiples variables, y combinar los resultados con `list_rbind()`.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}