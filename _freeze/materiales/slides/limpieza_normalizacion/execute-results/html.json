{
  "hash": "72a883d89e7e89584310d65fe2260051",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Limpieza y Normalizaci√≥n de Datos\"\nsubtitle: \"An√°lisis de Datos 1\"\nauthor: \"Betsy Cohen\"\nlogo: \"images/logo-uflo.png\"\nformat:\n  revealjs:\n    width: 1600\n    height: 900\n    theme: slides.scss\n    highlight-style: a11y\n    transition: fade\n    slide-number: true\nexecute:\n  echo: true\ndf-print: kable\n---\n\n\n\n\n# üëãEncerar y pulir {.smaller}\n\n::: columns\n::: {.column width=\"50%\"}\nEn esta clase abordaremos los conceptos fundamentales de **limpieza y normalizaci√≥n de datos**. Para trabajar con datos de manera efectiva, es crucial garantizar su **calidad**. Seg√∫n Schmidt et al. (2021), podemos evaluar la calidad de los datos a partir de los siguientes criterios:\n\n-   **Integridad**: ¬øEn qu√© grado los datos cumplen requisitos a nivel t√©cnico y de su estructura?\n\n-   **Completitud**: ¬øEn qu√© grado los valores esperados est√°n presentes?\n\n-   **Consistencia**: ¬øEn qu√© grado los valores de los datos est√°n libres de rupturas de convenciones o contradicciones?\n\n-   **Exactitud**: ¬øCu√°l es el grado de acuerdo entre distribuciones y asociaciones observadas y esperadas?\n:::\n\n::: {.column width=\"50%\"}\n![](https://media.giphy.com/media/J2xkAW1E8kvyE/giphy.gif){fig-align=\"right\"}\n:::\n:::\n\n# 1. Limpieza de nombres de variables {.smaller}\n\nUno de los primeros pasos en la limpieza de datos es asegurarnos de que los nombres de las variables sean **claros, consistentes y f√°ciles de manejar**. Para esto, utilizaremos el paquete `janitor` y su funci√≥n `clean_names()`, que convierte los nombres de las columnas a formato **snake_case**.\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\n# Ejemplo de un dataset con nombres desordenados\ndf <- data.frame(\n  \"C√≥digo ID\" = 1:4,\n  \"Nombre Completo\" = c(\"Ana P√©rez\", \"Juan G√≥mez\", \"Mar√≠a L√≥pez\", \"Ana P√©rez\"),\n  \"Ingreso Mensual\" = c(30000, 45000,50000,30000)\n)\n# Limpiar nombres de variables\n\ndf <- clean_names(df)\n```\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"codigo_id\"       \"nombre_completo\" \"ingreso_mensual\"\n```\n\n\n:::\n:::\n\n:::\n:::\n\n# 2. Detecci√≥n de valores faltantes {.smaller}\n\nEs importante identificar si hay datos faltantes en nuestro conjunto de datos. Podemos hacerlo con `is.na()` y algunas funciones de `dplyr`.\n\n::: columns\n::: column\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Introducimos algunos valores faltantes\ndf$ingreso_mensual[2] <- NA\n\n# Contar valores faltantes por variable\ncolSums(is.na(df))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      codigo_id nombre_completo ingreso_mensual \n              0               0               1 \n```\n\n\n:::\n:::\n\n:::\n::: column\n\n::: {.cell}\n\n```{.r .cell-code}\n# Filtrar registros con datos faltantes\ndf %>% filter(is.na(ingreso_mensual))\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| codigo_id|nombre_completo | ingreso_mensual|\n|---------:|:---------------|---------------:|\n|         2|Juan G√≥mez      |              NA|\n\n</div>\n:::\n:::\n\n:::\n:::\n\n# 3. Identificaci√≥n de valores √∫nicos {.smaller}\n\nPodemos analizar los valores √∫nicos y detectar duplicados con `distinct()`.\n\n\n::: {.cell output-location='column'}\n\n```{.r .cell-code}\n# Ver valores √∫nicos\ndistinct(df, nombre_completo)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|nombre_completo |\n|:---------------|\n|Ana P√©rez       |\n|Juan G√≥mez      |\n|Mar√≠a L√≥pez     |\n\n</div>\n:::\n:::\n\n\n# 3. Identificaci√≥n de valores √∫nicos y duplicados {.smaller}\n\nTambi√©n podemos usar `get_dupes()` de `janitor()`\n\n\n::: {.cell output-location='column'}\n\n```{.r .cell-code}\ndf %>% \n  janitor::get_dupes(nombre_completo)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|nombre_completo | dupe_count| codigo_id| ingreso_mensual|\n|:---------------|----------:|---------:|---------------:|\n|Ana P√©rez       |          2|         1|           30000|\n|Ana P√©rez       |          2|         4|           30000|\n\n</div>\n:::\n:::\n\n\n# 4. Validaciones estructuradas con `validate`\n\nEl paquete `validate` nos permite definir reglas de validaci√≥n y aplicarlas sistem√°ticamente sobre nuestros datos. `validate` permite verificar m√∫ltiples reglas al mismo tiempo y generar informes detallados sobre el cumplimiento de los datos.\n\n## ¬øComo funciona validate?\n\nCon `validate`, podemos definir un conjunto de reglas y aplicarlas sobre un dataset, obteniendo un resumen de qu√© reglas se cumplen o fallan.\n\nLa sintaxis general siempre va a ir teniendo una estructura como esta\n\n`reglas <- validator(tatuaje_en_cuello == \"S√≠\" ,el_pelo_negro == \"S√≠` ``` \"``) ```\n\n`resultado <- confront(dataset, reglas)`\n\n::: callout-note\nPodes leer m√°s sobre validate y los tipos de validaci√≥n que te permite hacer en el libro en ingl√©s por ahora) [\"The Data Validation Cookbook\"](https://data-cleaning.github.io/validate/)\n:::\n\n## Un ejemplo sencillo {.smaller}\n\nlas primeras tres reglas son comprobaciones de registros: cada registro arrojar√° una respuesta. En la √∫ltima regla, comprobamos si la velocidad y la distancia est√°n correlacionadas positivamente; esto arrojar√° una √∫nica respuesta¬†`TRUE`o¬†`FALSE`para todo el conjunto de datos.\n\nEl dataframe de resultado con una l√≠nea de informaci√≥n para cada regla `V1`, `V2`, `V3`y `V4`. Para ser precisos:\n\n-   ¬øCu√°ntos elementos de datos se comprobaron con cada regla?\n\n-   ¬øCu√°ntos elementos se aprobaron, fallaron o dieron como resultado `NA`?\n\n-   Si la verificaci√≥n result√≥ en un error (no se pudo realizar) o dio una advertencia.\n\n-   La expresi√≥n que realmente se evalu√≥ para realizar la verificaci√≥n.\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\n# reglas para dataset de autos\nreglas <- validator(speed >= 0\n                 , dist >= 0\n                 , speed/dist <= 1.5\n                 , cor(speed, dist)>=0.2)\n\nresultado   <- confront(cars, reglas)\n```\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(resultado)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|name | items| passes| fails| nNA|error |warning |expression              |\n|:----|-----:|------:|-----:|---:|:-----|:-------|:-----------------------|\n|V1   |    50|     50|     0|   0|FALSE |FALSE   |speed - 0 >= -1e-08     |\n|V2   |    50|     50|     0|   0|FALSE |FALSE   |dist - 0 >= -1e-08      |\n|V3   |    50|     48|     2|   0|FALSE |FALSE   |speed/dist <= 1.5       |\n|V4   |     1|      1|     0|   0|FALSE |FALSE   |cor(speed, dist) >= 0.2 |\n\n</div>\n:::\n:::\n\n:::\n:::\n\n## Interpretando los resultados {.smaller}\n\nLa misma informaci√≥n se puede resumir gr√°ficamente de la siguiente manera, donde cada barra horizontal indica el porcentaje de casos de Reprobado, Aprobado y Omitido.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(resultado)\n```\n\n::: {.cell-output-display}\n![](limpieza_normalizacion_files/figure-revealjs/unnamed-chunk-10-1.png){width=960}\n:::\n:::\n\n\nSiguiendo los criterios de **Integridad**, **Completitud**, **Consistencia** y **Exatitud** que mencion√°mos veamos algunos ejemplos de c√≥mo podemos usar `validate` para revisar nuestra base\n\n## üìå Cargar el dataset Palmer Penguins {.smaller .scrollable}\n\nUsaremos la base de datos penguins_raw del paquete palmerpenguins, que contiene errores comunes como valores faltantes, nombres inconsistentes y datos mal ingresados.\n\n¬øQu√© cosas ya le ves de entrada que estan mal?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#install.packages(\"palmerpenguins\")\nlibrary(palmerpenguins)\n\n# Cargamos la base de datos cruda de ping√ºinos\ndf <- palmerpenguins::penguins_raw\n\n# Revisamos los primeros registros\nhead(df)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|studyName | Sample Number|Species                             |Region |Island    |Stage              |Individual ID |Clutch Completion |Date Egg   | Culmen Length (mm)| Culmen Depth (mm)| Flipper Length (mm)| Body Mass (g)|Sex    | Delta 15 N (o/oo)| Delta 13 C (o/oo)|Comments                       |\n|:---------|-------------:|:-----------------------------------|:------|:---------|:------------------|:-------------|:-----------------|:----------|------------------:|-----------------:|-------------------:|-------------:|:------|-----------------:|-----------------:|:------------------------------|\n|PAL0708   |             1|Adelie Penguin (Pygoscelis adeliae) |Anvers |Torgersen |Adult, 1 Egg Stage |N1A1          |Yes               |2007-11-11 |               39.1|              18.7|                 181|          3750|MALE   |                NA|                NA|Not enough blood for isotopes. |\n|PAL0708   |             2|Adelie Penguin (Pygoscelis adeliae) |Anvers |Torgersen |Adult, 1 Egg Stage |N1A2          |Yes               |2007-11-11 |               39.5|              17.4|                 186|          3800|FEMALE |           8.94956|         -24.69454|NA                             |\n|PAL0708   |             3|Adelie Penguin (Pygoscelis adeliae) |Anvers |Torgersen |Adult, 1 Egg Stage |N2A1          |Yes               |2007-11-16 |               40.3|              18.0|                 195|          3250|FEMALE |           8.36821|         -25.33302|NA                             |\n|PAL0708   |             4|Adelie Penguin (Pygoscelis adeliae) |Anvers |Torgersen |Adult, 1 Egg Stage |N2A2          |Yes               |2007-11-16 |                 NA|                NA|                  NA|            NA|NA     |                NA|                NA|Adult not sampled.             |\n|PAL0708   |             5|Adelie Penguin (Pygoscelis adeliae) |Anvers |Torgersen |Adult, 1 Egg Stage |N3A1          |Yes               |2007-11-16 |               36.7|              19.3|                 193|          3450|FEMALE |           8.76651|         -25.32426|NA                             |\n|PAL0708   |             6|Adelie Penguin (Pygoscelis adeliae) |Anvers |Torgersen |Adult, 1 Egg Stage |N3A2          |Yes               |2007-11-16 |               39.3|              20.6|                 190|          3650|MALE   |           8.66496|         -25.29805|NA                             |\n\n</div>\n:::\n:::\n\n\n## Validaci√≥n de Completitud {.smaller .scrollable}\n\nVamos a empezar por la completitud. ¬øQu√© tan \"completo\" est√° penguins_raw?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Generamos reglas \nreglas_completitud_raw <- validator(sin_faltantes_raw = is_complete(df)) # Regla general de completitud para TODO el dataset\n\n# Confrontamos df con las reglas\nresultado_completitud_raw <- confront(df, reglas_completitud_raw)\n\nsummary(resultado_completitud_raw) # Imprimir resultados\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|name              | items| passes| fails| nNA|error |warning |expression      |\n|:-----------------|-----:|------:|-----:|---:|:-----|:-------|:---------------|\n|sin_faltantes_raw |   344|     34|   310|   0|FALSE |FALSE   |is_complete(df) |\n\n</div>\n:::\n:::\n\n\nEse summary lo leemos as√≠:\n\n-   *name*: El nombre de la regla.\n\n-   *items*: El dataset tiene 344 elementos que se est√°n evaluando.\n\n-   *passes*: De esos 344 elementos, 310 cumplen con la regla, es decir, no tienen valores faltantes.\n\n-   *fails:* ego 34 no la pasaron.\n\n-   *nNA*: es el n√∫mero de valores faltantes (NA) identificados en el dataset. ojo porque por ah√≠ todavia no creamos la regla adecuada para detectarlos.\n\n-   *error*: FALSE: Quiere decuir que no hubo errores en la evaluaci√≥n de la regla.\n\n-   *warning*: FALSE: No hay advertencias durante la evaluaci√≥n.\n\n-   *expression*: is_complete(df): La expresi√≥n que se utiliz√≥ para la validaci√≥n, que en este caso verifica la completitud del dataset sin faltantes.\n\n## Validaci√≥n de Integridad\n\nVamos a verificar si hay filas duplicadas.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Reglas de integridad para penguins_raw (df)\nreglas_integridad_raw <- validator(\n    sin_faltantes_raw = is_complete(df), # (General - no relevante aqu√≠)\n    sin_duplicados_raw = is_unique(df) # Regla de integridad: registros √∫nicos\n)\n\n# Confrontamos penguins_raw (df) con las reglas de integridad\nresultado_integridad_raw <- confront(df, reglas_integridad_raw)\n\nsummary(resultado_integridad_raw) # Imprimir resultados\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|name               | items| passes| fails| nNA|error |warning |expression      |\n|:------------------|-----:|------:|-----:|---:|:-----|:-------|:---------------|\n|sin_faltantes_raw  |   344|     34|   310|   0|FALSE |FALSE   |is_complete(df) |\n|sin_duplicados_raw |   344|    344|     0|   0|FALSE |FALSE   |is_unique(df)   |\n\n</div>\n:::\n:::\n\n\n## Validaci√≥n de Exactitud {.smaller .scrollable}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreglas_exactitud_raw <- validator(\n\n    sin_faltantes_dataset_raw = is_complete(df), # (General)\n    sin_duplicados_raw = is_unique(df), # (Integridad)\n\n    # Reglas de completitud:\n    culmen_length_mm_no_na_raw = !is.na(`Culmen Length (mm)`), # \n    culmen_depth_mm_no_na_raw = !is.na(`Culmen Depth (mm)`),\n    flipper_length_mm_no_na_raw = !is.na(`Flipper Length (mm)`),\n    body_mass_g_no_na_raw = !is.na(`Body Mass (g)`),\n    sex_no_na_raw = !is.na(Sex), # Completitud para 'Sex'\n\n    # Reglas de Categor√≠as V√°lidas (Consistencia de Categor√≠as):\n    categorias_especie_raw = Species %in% c(\"Adelie Penguin (Pygoscelis adeliae)\", \"Chinstrap penguin (Pygoscelis antarctica)\", \"Gentoo penguin (Pygoscelis papua)\"), # Categor√≠as v√°lidas para 'Species'\n    categorias_isla_raw = Island %in% c(\"Biscoe\", \"Dream\", \"Torgersen\"), # Categor√≠as v√°lidas para 'Island'\n    categorias_sexo_raw = Sex %in% c(\"MALE\", \"FEMALE\", \".\") # Categor√≠as v√°lidas para 'Sex' (¬°incluimos \".\"!)\n)\n\n# Confrontar penguins_raw (df) con las reglas de exactitud\nresultado_exactitud_raw <- confront(df, reglas_exactitud_raw)\nsummary(resultado_exactitud_raw) # Imprimir resultado\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|name                        | items| passes| fails| nNA|error |warning |expression                                                                                                                               |\n|:---------------------------|-----:|------:|-----:|---:|:-----|:-------|:----------------------------------------------------------------------------------------------------------------------------------------|\n|sin_faltantes_dataset_raw   |   344|     34|   310|   0|FALSE |FALSE   |is_complete(df)                                                                                                                          |\n|sin_duplicados_raw          |   344|    344|     0|   0|FALSE |FALSE   |is_unique(df)                                                                                                                            |\n|culmen_length_mm_no_na_raw  |   344|    342|     2|   0|FALSE |FALSE   |!is.na(`Culmen Length (mm)`)                                                                                                             |\n|culmen_depth_mm_no_na_raw   |   344|    342|     2|   0|FALSE |FALSE   |!is.na(`Culmen Depth (mm)`)                                                                                                              |\n|flipper_length_mm_no_na_raw |   344|    342|     2|   0|FALSE |FALSE   |!is.na(`Flipper Length (mm)`)                                                                                                            |\n|body_mass_g_no_na_raw       |   344|    342|     2|   0|FALSE |FALSE   |!is.na(`Body Mass (g)`)                                                                                                                  |\n|sex_no_na_raw               |   344|    333|    11|   0|FALSE |FALSE   |!is.na(Sex)                                                                                                                              |\n|categorias_especie_raw      |   344|    344|     0|   0|FALSE |FALSE   |Species %vin% c(\"Adelie Penguin (Pygoscelis adeliae)\", \"Chinstrap penguin (Pygoscelis antarctica)\", \"Gentoo penguin (Pygoscelis papua)\") |\n|categorias_isla_raw         |   344|    344|     0|   0|FALSE |FALSE   |Island %vin% c(\"Biscoe\", \"Dream\", \"Torgersen\")                                                                                           |\n|categorias_sexo_raw         |   344|    333|     0|  11|FALSE |FALSE   |Sex %vin% c(\"MALE\", \"FEMALE\", \".\")                                                                                                       |\n\n</div>\n:::\n:::\n\n\n## Validaci√≥n de Consistencia {.smaller .scrollable}\n\nFinalmente, vamos a verificar la consistencia de tipos de datos en penguins_raw. Ya vimos con glimpse() que muchas columnas num√©ricas se importaron como character. Vamos a usar validate para confirmar y cuantificar este problema de consistencia de tipo de datos.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreglas_consistencia_raw <- validator(\n\n    sin_faltantes_dataset_raw = is_complete(df), # (General - no foco)\n    sin_duplicados_raw = is_unique(df), # (Integridad - no foco)\n    culmen_length_mm_no_na_raw = !is.na(`Culmen Length (mm)`), # (Exactitud - no foco ahora)\n    culmen_depth_mm_no_na_raw = !is.na(`Culmen Depth (mm)`),\n    flipper_length_mm_no_na_raw = !is.na(`Flipper Length (mm)`),\n    body_mass_g_no_na_raw = !is.na(`Body Mass (g)`),\n    sex_no_na_raw = !is.na(Sex),\n    categorias_especie_raw = Species %in% c(\"Adelie Penguin (Pygoscelis adeliae)\", \"Chinstrap penguin (Pygoscelis antarctica)\", \"Gentoo penguin (Pygoscelis papua)\"),\n    categorias_isla_raw = Island %in% c(\"Biscoe\", \"Dream\", \"Torgersen\"),\n    categorias_sexo_raw = Sex %in% c(\"MALE\", \"FEMALE\", \".\"),\n\n    # Reglas de Consistencia de TIPO DE DATOS (¬°Aqu√≠ est√° el foco!):\n    culmen_length_mm_es_numerico_raw = is.numeric(`Culmen Length (mm)`), # ¬°Consistencia de tipo para 'Culmen Length (mm)'!\n    culmen_depth_mm_es_numerico_raw = is.numeric(`Culmen Depth (mm)`),\n    flipper_length_mm_es_numerico_raw = is.numeric(`Flipper Length (mm)`),\n    body_mass_g_es_numerico_raw = is.numeric(`Body Mass (g)`),\n    sex_es_factor_raw = is.factor(Sex), # Verificar si 'Sex' es factor (¬°deber√≠a ser categ√≥rica!)\n    species_es_factor_raw = is.factor(Species), # Verificar si 'Species' es factor\n    island_es_factor_raw = is.factor(Island) # Verificar si 'Island' es factor\n)\n\nsalida_consistencia_raw <- confront(df, reglas_consistencia_raw)\n\nsummary(salida_consistencia_raw) # Resumen del resultado de consistencia de tipos\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|name                              | items| passes| fails| nNA|error |warning |expression                                                                                                                               |\n|:---------------------------------|-----:|------:|-----:|---:|:-----|:-------|:----------------------------------------------------------------------------------------------------------------------------------------|\n|sin_faltantes_dataset_raw         |   344|     34|   310|   0|FALSE |FALSE   |is_complete(df)                                                                                                                          |\n|sin_duplicados_raw                |   344|    344|     0|   0|FALSE |FALSE   |is_unique(df)                                                                                                                            |\n|culmen_length_mm_no_na_raw        |   344|    342|     2|   0|FALSE |FALSE   |!is.na(`Culmen Length (mm)`)                                                                                                             |\n|culmen_depth_mm_no_na_raw         |   344|    342|     2|   0|FALSE |FALSE   |!is.na(`Culmen Depth (mm)`)                                                                                                              |\n|flipper_length_mm_no_na_raw       |   344|    342|     2|   0|FALSE |FALSE   |!is.na(`Flipper Length (mm)`)                                                                                                            |\n|body_mass_g_no_na_raw             |   344|    342|     2|   0|FALSE |FALSE   |!is.na(`Body Mass (g)`)                                                                                                                  |\n|sex_no_na_raw                     |   344|    333|    11|   0|FALSE |FALSE   |!is.na(Sex)                                                                                                                              |\n|categorias_especie_raw            |   344|    344|     0|   0|FALSE |FALSE   |Species %vin% c(\"Adelie Penguin (Pygoscelis adeliae)\", \"Chinstrap penguin (Pygoscelis antarctica)\", \"Gentoo penguin (Pygoscelis papua)\") |\n|categorias_isla_raw               |   344|    344|     0|   0|FALSE |FALSE   |Island %vin% c(\"Biscoe\", \"Dream\", \"Torgersen\")                                                                                           |\n|categorias_sexo_raw               |   344|    333|     0|  11|FALSE |FALSE   |Sex %vin% c(\"MALE\", \"FEMALE\", \".\")                                                                                                       |\n|culmen_length_mm_es_numerico_raw  |     1|      1|     0|   0|FALSE |FALSE   |is.numeric(`Culmen Length (mm)`)                                                                                                         |\n|culmen_depth_mm_es_numerico_raw   |     1|      1|     0|   0|FALSE |FALSE   |is.numeric(`Culmen Depth (mm)`)                                                                                                          |\n|flipper_length_mm_es_numerico_raw |     1|      1|     0|   0|FALSE |FALSE   |is.numeric(`Flipper Length (mm)`)                                                                                                        |\n|body_mass_g_es_numerico_raw       |     1|      1|     0|   0|FALSE |FALSE   |is.numeric(`Body Mass (g)`)                                                                                                              |\n|sex_es_factor_raw                 |     1|      0|     1|   0|FALSE |FALSE   |is.factor(Sex)                                                                                                                           |\n|species_es_factor_raw             |     1|      0|     1|   0|FALSE |FALSE   |is.factor(Species)                                                                                                                       |\n|island_es_factor_raw              |     1|      0|     1|   0|FALSE |FALSE   |is.factor(Island)                                                                                                                        |\n\n</div>\n:::\n:::\n\n\n## ¬°Y as√≠ llegamos al fin de la unidad 3! {.smaller}\n\nHoy aprendimos a:\n\n-   **Preparar nuestros datos para el an√°lisis**: Empezamos limpiando los nombres de las variables con janitor::clean_names() para que sean m√°s manejables y consistentes.\n\n-   **Detectar problemas comunes de calidad de datos:** Exploramos c√≥mo identificar valores faltantes, duplicados y valores √∫nicos utilizando funciones b√°sicas de R y dplyr.\n\n-   **Validar nuestros datos de forma estructurada con validate:** Aprendimos a definir reglas para evaluar la completitud, integridad, exactitud y consistencia de nuestros datos. Vimos c√≥mo usar las funciones clave de validate (validator, confront, summary, plot) para aplicar estas reglas al dataset penguins_raw.\n\n-   **Cuantificar y resumir los problemas de calidad de datos**: Comprobamos c√≥mo validate no solo detecta los problemas, sino que tambi√©n nos proporciona informaci√≥n detallada y resumida sobre cu√°ntos registros fallan en cada regla y d√≥nde se encuentran los errores.\n",
    "supporting": [
      "limpieza_normalizacion_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}