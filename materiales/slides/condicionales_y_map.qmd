---
title: "An√°lisis Exploratorio, Transformaci√≥n Condicional y Funciones con `map()`"
subtitle: "An√°lisis de Datos 1"
author: "Betsy Cohen"
logo: "images/logo-uflo.png"
date: "08/05/2025"
format:
  revealjs:
    width: 1600
    height: 900
    theme: slides.scss
    highlight-style: a11y
    transition: fade
    slide-number: true
execute:
  echo: true
df-print: kable
---

```{r}
#| context: setup
#| include: false

# Cargar librer√≠as (reutilizamos setup previo)
library(tidyverse)
library(purrr) # Cargamos el paquete purrr

# Cargar datos ENCC 2022 (reutilizamos carga previa)
url <- "https://datos.cultura.gob.ar/dataset/251c2ac2-e670-451c-9dbf-a4212af225b5/resource/b635d1fc-2161-4901-a21d-7f93d56d99a4/download/base-datos-encc-2022-2023.csv"

encc_2022 <- read.csv(url)
```

# Exploraci√≥n, Transformaci√≥n Condicional y la Magia de map() üöÄ

En la clase de hoy, vamos a explorar tres aspectos fundamentales del an√°lisis de datos:

-   Repaso de An√°lisis Exploratorio y Descriptivo: Res√∫menes clave para datos num√©ricos y categ√≥ricos.
-   L√≥gica Condicional con if_else() y case_when(): Transformaci√≥n de datos basada en condiciones.
-   Introducci√≥n a purrr::map(): La funci√≥n map() para aplicar operaciones a m√∫ltiples elementos de forma eficiente y elegante.

# An√°lisis Exploratorio y Descriptivo üîç

Vamos a repasar brevemente las herramientas esenciales para entender nuestros datos, tanto num√©ricos como categ√≥ricos.

## Datos Num√©ricos: Res√∫menes Estad√≠sticos üî¢ {.smaller}

Para variables num√©ricas, los res√∫menes estad√≠sticos nos ofrecen una visi√≥n r√°pida de su distribuci√≥n y caracter√≠sticas.

**Herramientas:**

-   `summarize()`: Para calcular estad√≠sticos como media, mediana, desviaci√≥n est√°ndar, etc.

    ```{r}
    resumen_edad <- encc_2022 %>%
      summarize(
        media_edad = mean(edad, na.rm = TRUE),
        mediana_edad = median(edad, na.rm = TRUE),
        desvio_std_edad = sd(edad, na.rm = TRUE),
        min_edad = min(edad, na.rm = TRUE),
        max_edad = max(edad, na.rm = TRUE),
        rango_edad = max_edad - min_edad,
        iqr_edad = IQR(edad, na.rm = TRUE),
        cantidad_encuestados = n()
      )
    ```

## Datos Num√©ricos: Res√∫menes Estad√≠sticos üî¢

::: columns
::: {.column width="50%"}
Esta tabla nos presenta un resumen conciso de la distribuci√≥n de la edad en la muestra, mostrando medidas de tendencia central, dispersi√≥n y rango.
:::

::: {.column width="50%"}
```{r}
resumen_edad
```
:::
:::

## Datos Categ√≥ricos: Tablas de Frecuencia üìä {.smaller}

Para variables categ√≥ricas, las tablas de frecuencia nos muestran la distribuci√≥n de las categor√≠as y su importancia relativa.

::: columns
::: {.column width="50%"}
**Herramientas:**

-   `count()`: Para contar las ocurrencias de cada categor√≠a.

-   `mutate()`: Para calcular proporciones y porcentajes a partir de las frecuencias.
:::

::: {.column width="50%"}
```{r}
frecuencia_regiones_prop <- encc_2022 %>%
  count(region, sort = TRUE) %>%
  mutate(
    proporcion = n / sum(n),
    porcentaje = proporcion * 100
  )

frecuencia_regiones_prop
```
:::
:::

Esta tabla muestra las regiones ordenadas por frecuencia, junto con la cantidad de encuestados en cada regi√≥n, su proporci√≥n y porcentaje respecto al total de la muestra.

# L√≥gica Condicional: `if_else()` y `case_when()` ü§î

## `if_else()`: Condiciones Binarias (SI/NO) üí° {.smaller}

`if_else()` es ideal para crear variables basadas en una condici√≥n que tiene dos resultados posibles.

**Ejemplo: Variable `es_mayor_de_50`**

Creemos una variable que indique si la edad del encuestado es mayor de 50 a√±os (SI/NO).

```{r}
encc_mayor_50 <- encc_2022 %>%
  mutate(
    es_mayor_de_50 = if_else(edad > 50, "SI", "NO")
  )

encc_mayor_50 %>% count(es_mayor_de_50)
```

`if_else()` asigna "SI" a `es_mayor_de_50` si `edad > 50` es verdadero, y "NO" en caso contrario.

## `case_when()`: Condiciones M√∫ltiples y Categor√≠as üé≠ {.smaller}

`case_when()` es perfecto para l√≥gica condicional m√°s compleja con m√∫ltiples categor√≠as.

Recategorizamos `nse_3` en "Alto/Medio", "Bajo" y "Sin Dato".

::: columns
::: {.column width="50%"}
```{r}

encc_nse_reducido <- encc_2022 %>%
  mutate(
    nse_reducido = case_when(
      nse_3 %in% c("ABC1", "C2C3") ~ "Alto/Medio",
      nse_3 == "D1D2E"           ~ "Bajo",
      TRUE                         ~ "Sin Dato"
    )
  )

```
:::

::: {.column width="50%"}
```{r}
encc_nse_reducido %>% count(nse_reducido)
```
:::
:::

`case_when()` asigna categor√≠as a `nse_reducido` basadas en diferentes condiciones aplicadas a `nse_3`, incluyendo un valor por defecto "Sin Dato".

::: callout-note
case_when () es una de las estructuras de transformaci√≥n que seguramente m√°s vas usar. Si ya contas con algo de experiencia en an√°lisis de datos y trabajaste con SPSS case_when() es uno de los procesos que hacemos m√°s habitualmente en lo que llamamos **rectegorizaci√≥n** de variables
:::

# Introducci√≥n a `purrr::map()`: La Magia de la Iteraci√≥n Funcional ‚ú®

Ahora vamos a introducir una herramienta muy poderosa para **automatizar tareas repetitivas**: la funci√≥n `map()` del paquete `purrr`.

## ¬øQu√© es `map()`?

-   `map()` es una funci√≥n que permite aplicar la **misma funci√≥n** a **cada elemento de una lista o vector**.

-   Simplifica y hace m√°s eficiente el c√≥digo cuando necesitamos realizar la misma operaci√≥n en m√∫ltiples columnas o elementos.

-   Es un concepto clave de la **programaci√≥n funcional**.

## Sintaxis b√°sica de `map()`:

map() nos va a pedir dos elementos b√°sicos para operar como parte de su sintaxis

-   `x`: El **vector o lista** sobre el cual queremos iterar.

<!-- -->

-   `.f`: La **funci√≥n** que queremos aplicar a cada elemento de `.x`.

Como resultado devuelve una **lista** donde cada elemento es el resultado de aplicar la funci√≥n `.f` al elemento correspondiente de `.x`.

Veamos un ejemplo

## Calcular Tablas de Frecuencia para M√∫ltiples Variables Categ√≥ricas con `map()` y `count()` üìä {.smaller}

Supongamos que queremos obtener las tablas de frecuencia para varias variables categ√≥ricas de la ENCC_2022: `region`, `genero`, `nivel_educativo`. En lugar de escribir `count()` para cada variable por separado, podemos usar `map()` para automatizar este proceso.

```{r}
variables_categoricas <- c("region", "genero", "niv_socioe") # Vector de nombres de variables categ√≥ricas

frecuencias_variables <- map(
  .x = variables_categoricas, # Vector de nombres de variables categ√≥ricas sobre el que iterar
  .f = function(variable) { # Funci√≥n an√≥nima que toma el nombre de una variable como argumento
    encc_2022 %>%
      count(!!sym(variable), sort = TRUE) # Calcula la tabla de frecuencia para la variable en el dataset encc_2022
  }
)

```

## Calcular Tablas de Frecuencia para M√∫ltiples Variables Categ√≥ricas con `map()` y `count()` üìä {.smaller}

```{r}
frecuencias_variables # Imprimir la lista de data frames de frecuencias
```

## üò±Pero ... ¬ø¬°Qu√© es esta locura!?

-   `map()` iter√≥ sobre el vector `variables_categoricas`. Para cada nombre de variable (ej., "region"), aplic√≥ la funci√≥n an√≥nima.

<!-- -->

-   La funci√≥n an√≥nima usa `count(!!sym(variable), sort = TRUE)` para calcular la tabla de frecuencia de la variable actual, ordenando por frecuencia descendente.

<!-- -->

-   `!!sym(variable)`: Recordemos que esto permite usar el nombre de la variable din√°micamente dentro de `count()`.

<!-- -->

-   El resultado `frecuencias_variables` es una **lista**, donde cada elemento es un **data frame** que representa la tabla de frecuencia para una de las variables categ√≥ricas. Cada data frame muestra las categor√≠as y sus frecuencias (`n`).

## Calcular Tablas de Proporciones para M√∫ltiples Variables Categ√≥ricas con `map()` y Funciones Anidadas üìà {.smaller}

Ahora, vamos a calcular las tablas de proporciones (y porcentajes) para las mismas variables categ√≥ricas (`region`, `genero`, `nivel_educativo`). Vamos a anidar funciones dentro de `map()` para realizar los c√°lculos de proporci√≥n dentro de cada tabla de frecuencia.

```{r}
proporciones_variables <- map(
  .x = variables_categoricas, # Vector de nombres de variables categ√≥ricas
  .f = function(variable) { # Funci√≥n an√≥nima para calcular tabla de proporciones para una variable
    encc_2022 %>%
      count(!!sym(variable), sort = TRUE) %>% # Primero, calcular la tabla de frecuencia
      mutate( # Luego, dentro de la misma funci√≥n an√≥nima, calcular proporciones y porcentajes
        proporcion = n / sum(n),
        porcentaje = proporcion * 100
      )
  }
)

```

## Calcular Tablas de Proporciones para M√∫ltiples Variables Categ√≥ricas con `map()` y Funciones Anidadas üìà

```{r}
proporciones_variables # Imprimir la lista de data frames de proporciones
```

## ¬°Es m√°gico!

-   De nuevo, `map()` iter√≥ sobre `variables_categoricas`.

<!-- -->

-   La funci√≥n an√≥nima ahora realiza dos operaciones anidadas:

    1.  `count(!!sym(variable), sort = TRUE)`: Calcula la tabla de frecuencia (como el ej. anterior).

    2.  `mutate(proporcion = n / sum(n), porcentaje = proporcion * 100)`: *Dentro del mismo pipe*, calcula las columnas `proporcion` y `porcentaje` a partir de la frecuencia `n` de la tabla de frecuencia.

-   El resultado `proporciones_variables` es una **lista**, donde cada elemento es un **data frame** que contiene la tabla de frecuencia y las proporciones/porcentajes para cada variable categ√≥rica.

## La yapa: Combinar las Tablas en un Solo Data Frame con `list_rbind()` y un ID de Variable üß≤ {.smaller}

Finalmente, combinemos las listas de tablas de proporciones (`proporciones_variables`) en un √∫nico data frame "largo", y agreguemos una columna `variable` para identificar a qu√© variable categ√≥rica corresponde cada tabla.

```{r}
proporciones_variables_df <- proporciones_variables %>%
  list_rbind(names_to = "variable") # Combinar la lista en un data frame y usar 'names_to' para crear columna 'variable'

str(proporciones_variables_df)
```

Ahora tenemos un data frame "tidy" donde cada fila representa una categor√≠a de una variable categ√≥rica, con columnas para la variable, la categor√≠a, la frecuencia, la proporci√≥n y el porcentaje. Este formato facilita la comparaci√≥n de distribuciones entre diferentes variables categ√≥ricas, y puede ser usado para crear visualizaciones tabulares o gr√°ficas comparativas (aunque en esta clase no estemos usando gr√°ficos).

## `map()`: Un Universo de Posibilidades üåå {.smaller}

La funci√≥n `map()` es extremadamente vers√°til y puede usarse con una gran variedad de funciones y prop√≥sitos. En clases futuras, exploraremos m√°s usos de `map()` y otras funciones del paquete `purrr` para la programaci√≥n funcional y la manipulaci√≥n de datos avanzada.

**En resumen, `map()` nos permite:**

-   **Automatizar tareas repetitivas** de forma eficiente y concisa.

-   **Aplicar la misma l√≥gica a m√∫ltiples columnas o elementos** de una lista o vector.

-   **Escribir c√≥digo m√°s limpio, legible y mantenible**.

-   **Adoptar un estilo de programaci√≥n funcional** que es poderoso y com√∫n en el ecosistema de R y `tidyverse`.

::: callout-note
Si te interesa aprender m√°s sobre map() y sus aplicaciones podes consultar la documentaci√≥n (que por suerte viene con muchos ejemplos) en <https://purrr.tidyverse.org/reference/map.html>
:::

# Resumen de la Clase de Hoy üöÄ

En la clase de hoy, cubrimos tres temas importantes:

-   **An√°lisis Exploratorio Descriptivo**: Repasamos res√∫menes estad√≠sticos para datos num√©ricos y tablas de frecuencia para datos categ√≥ricos.

-   **L√≥gica Condicional con `if_else()` y `case_when()`**: Reforzamos el uso de estas funciones para transformaciones basadas en condiciones.

-   **Introducci√≥n a `purrr::map()`**: Aprendimos los fundamentos de la funci√≥n `map()` para la iteraci√≥n funcional, y c√≥mo usar `map_dbl()` y `map()` para aplicar funciones a m√∫ltiples variables, y combinar los resultados con `list_rbind()`.
