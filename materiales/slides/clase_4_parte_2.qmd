---
title: "Introducci√≥n a Tidyverse: union y pivoteo de tablas"
subtitle: "An√°lisis de Datos 1"
author: "Betsy Cohen"
logo: "images/logo-uflo.png"
date: "10/04/2025"
format:
  revealjs:
    width: 1600
    height: 900
    theme: slides.scss
    highlight-style: a11y
    transition: fade
    slide-number: true
execute:
  echo: true
df-print: kable
---

```{r}
#| context: setup
#| include: false

# load libraries
library(tidyverse)

# load data
# url
url <- "https://datos.cultura.gob.ar/dataset/251c2ac2-e670-451c-9dbf-a4212af225b5/resource/b635d1fc-2161-4901-a21d-7f93d56d99a4/download/base-datos-encc-2022-2023.csv.csv"  

# lo asignamos a un objeto tabla con la funci√≥n read.csv
encc_2022 <- read.csv(url)

# Ejemplo tabla personas por g√©nero y regi√≥n 
encc_personas_por_genero_region <- encc_2022 %>%
  group_by(region,genero) %>%
  summarise(personas = n_distinct(id),.groups = "drop") %>%
  pivot_wider(names_from =  genero,
              values_from = personas)

# Ejemplo tabla personas por region (para joins - simplificada)
encc_personas_region <- encc_2022 %>%
  group_by(region) %>%
  summarise(total_personas = n_distinct(id), .groups = "drop")

# Ejemplo tabla tamanio localidad por region (para joins - inventada para ejemplo)
tamanio_localidad_region <- encc_2022 %>%
    group_by(region, tamanio) %>%
    summarise(conteo_tamanio = n(), .groups = "drop") %>%
    pivot_wider(names_from = tamanio, values_from = conteo_tamanio, values_fill = 0) # Rellenar con 0 los NA para ejemplo JOIN


```

# Clase de Hoy: M√°s All√° de los Verbos B√°sicos üöÄ

En la clase anterior, nos familiarizamos con los verbos esenciales del `dplyr` y c√≥mo combinarlos con pipes para transformar datos.

Ahora, vamos a expandir nuestro arsenal de herramientas del tidyverse explorando dos operaciones fundamentales:

-   Uni√≥n de Tablas (Joins): Combinar datos de m√∫ltiples tablas relacionadas.

-   Pivoteo de Tablas (Pivoting): Reorganizar la estructura de las tablas para facilitar el an√°lisis.

Estas operaciones son clave para trabajar con conjuntos de datos complejos y cuando quieras darte cuenta van a ser parte de tu trabajo diario con datos.

# Que las tablas sean unidas porque esa es la ley primera

## Qu√© es un join()

En el an√°lisis de datos, a menudo tenemos informaci√≥n distribuida en m√∫ltiples tablas relacionadas y necesitamos unirlas para combinar la informaci√≥n y poder analizarla en conjunto.

Ejemplo:

**Tabla 1:** `encc_personas_region`: Informaci√≥n agregada por regi√≥n

**Tabla 2:** `tamanio_localidad_region`: Informaci√≥n sobre el tama√±o de localidad por regi√≥n

Queremos unir estas tablas para tener en una sola tabla informaci√≥n combinada por regi√≥n.


## Que tipos de join() existen {.smaller}

`dplyr` nos ofrece una familia de funciones \*\*\*\_join()\*\* para realizar diferentes tipos de uniones de tablas, basadas en la l√≥gica de las bases de datos relacionales. Los principales tipos son:

|                                                                                                                                                                                                          |                                                                               |
|------------------------------------------------|-----------------------|
| **left_join:** Mantiene TODAS las filas de tabla_A (izquierda) y agrega las columnas correspondientes de tabla_B donde hay coincidencia en la columna_clave. Si no hay coincidencia, se completa con NA. | ![](images/left-join.gif){fig-align="center" fig-align="bottom" width="125"}  |
| **right_join:** Similar a left_join, pero mantiene TODAS las filas de tabla_B (derecha) y agrega las columnas de tabla_A donde hay coincidencia.                                                         | ![](images/right-join.gif){fig-align="center" fig-align="bottom" width="125"} |
| **inner_join:** Mantiene solo las filas que tienen coincidencia en la columna_clave en AMBAS tablas.Es la intersecci√≥n de las tablas.                                                                    | ![](images/inner-join.gif){fig-align="center" fig-align="bottom" width="125"} |
| **full_join:** Uni√≥n COMPLETA (EXTERNA). Mantiene TODAS las filas de AMBAS tablas, combinando las filas donde hay coincidencia y rellenando con NA donde no la hay. Es la uni√≥n de las tablas.           | ![](images/full-join.gif){fig-align="center" fig-align="bottom" width="125"}  |


## Otros tipos de join

::: callout-note

**semi_join** Uni√≥n SEMI-IZQUIERDA. Mantiene solo las filas de tabla_A que tienen coincidencia en la columna_clave en tabla_B, pero NO agrega las columnas de tabla_B. Sirve para filtrar tabla_A bas√°ndose en la presencia de coincidencias en tabla_B.

**anti_join** Uni√≥n ANTI-IZQUIERDA. Mantiene solo las filas de tabla_A que NO tienen coincidencia en la columna_clave en tabla_B. Sirve para filtrar tabla_A y quedarte solo con las filas sin coincidencias en tabla_B.
:::


¬øC√≥mo Unimos Tablas con dplyr? üõ†Ô∏è
Todas las funciones *_join() de dplyr comparten una sintaxis similar:

```r
nueva_tabla_unida <- tabla_A %>%
tipo_de_join(tabla_B, by = "columna_clave")
```

tabla_A %>% tipo_de_join(tabla_B, ...): Siempre empezamos con la tabla "izquierda" (tabla_A) y la "pipeamos" a la funci√≥n tipo_de_join().
tabla_B: Es la tabla "derecha" que queremos unir a tabla_A.
by = "columna_clave": CLAVE DE UNI√ìN. Especificamos qu√© columna (o columnas) se utilizan para encontrar las coincidencias entre las filas de tabla_A y tabla_B. Las tablas se unir√°n bas√°ndose en los valores compartidos en esta columna. El nombre de la columna clave debe ser el mismo en ambas tablas, o podemos usar by = c("columna_A" = "columna_B") si tienen nombres diferentes.




# Yo soy al derecho dado vuelta estas vos

## Qu√© es un pivoteo y en qu√© situaciones lo voy a necesitar {.smaller}

Muchas veces nos va a pasar que vamos a tener una tabla en la cual las categor√≠as que queremos mostrar (por ejemplo sexo, edad, provincia) se encuentran como nombres de columnas. Por ejemplo:

```{r}
encc_personas_por_genero_region
```

La variable `sexo` no existe como tal sino que se encuentra **repartida a lo ancho de la tabla como columnas** y entonces si nos pasan una tabla como esta no podr√≠amos aplicar operaciones como `filter()` y quedarnos s√≥lo con las mujeres

## Estirar a lo largo con pivot_longer {.smaller}

Para convertir a sexo en columna vamos a usar una funci√≥n muy √∫til llamada `pivot_longer`.

La funci√≥n nos pide al menos dos argumentos para operar (adem√°s de la tabla en cuesti√≥n, obviamente)

```{r}
encc_personas_por_genero_region_alargada <- encc_personas_por_genero_region %>% 
  pivot_longer(
    cols = c("Mujer","Var√≥n","No binario"), # qu√© columnas necesitas pivotear
    names_to = "sexo", # c√≥mo se va a llamar la variable a donde van a parar
    values_to = "personas" # (opcional) nombre de la columna a donde van a parar los valores pivoteados
    )

encc_personas_por_genero_region_alargada %>% 
  head(n=8)
```

## Estirar a lo largo con pivot_longer {.smaller}

Y ahora ya podemos hacer operaciones con esta tabla como por ejemplo filtrar solo a las muejeres

```{r}
encc_personas_por_genero_region_alargada %>% 
  filter(sexo == "Mujer")
```

## Estirar a lo ancho con pivot_wider {.smaller}

Pivot wider es (como ya te estaras imaginando) la operaci√≥n inversa. Los argumentos de esta funci√≥n entonces van a ser

```{r}
encc_personas_por_genero_region_alargada %>% 
  pivot_wider(names_from = "sexo", # que categorias tengo que poner como nombre de la variable que voy a estirar a lo ancho como columnas
              values_from = "personas") # Qu√© variable contiene los valores que debo repartir a lo ancho por esas columnas
```

:::{call-out tip} Si bien no es una regla, podr√≠amos pensar que pivot_longer va a transformar los datos de manera entendible para una m√°quina o para el trabajo con ellos como tablas de manera tidy, mientras que pivot_wider siempre nos da un formato :::

# across() the universe

# Qu√© aprendimos hasta ac√°
